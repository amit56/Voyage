Team: Amit Joshi and Dora Gurfinkel

Required Features:

Menger Sponge:

We define the vertices and faces for a square of variable side length s. We then use a recursive formula, that recurses to the given depth layer (0-4), and determines the location of all the cubes that will exist at the final recursion depth. If a square is in the middle of at least two axis (x, y or z, x or y, z etc.), then we know that that particular cube should not be rendered in the menger sponge. We then exclude it.

Camera Operations:
We initialize camera vectors to the values dictated by the spec.

We then fill in the view matrix element by element, as would be expected from the product of the translation and transformation matrices.

Translations simply modify the eye's location and then update center accordingly.
Rotation by the mouse keeps track of the delta between two mouse locations, translates that into the camera's basis, and then calculates an axis of rotation orthonormal to this vector and the look vector. Both look and camera up are rotated around this axis.

For rotating in place, controlled by left and right arrows, we simply rotate the camera_up vector around look. Rotate takes in radians so no conversion was necessary for the given speeds.

Obj Dump: Fairly simple, we just loop through the vertices and faces and print in the format that is standard.

Shaders:

Shading of sponge: To shade the sponge the right colors, we calculated the normals with respect to the world coordinates.  We passed world coordinates from the vertex shader into the geometry shader.  Then, depending on which axis (x, y, or z) the normal was facing (either positive or negative), we colored it red green or blue.  To find the light intensity.  We also changed vs_light_direction inside vertex shader to give itself in world coordinates, because we ran into a bug where rotating the camera would change the light intensity on the sponge surface.

Shading of floor: To shade floor, we passed in world coordinates through the entire pipeline of shaders.  We used the formula (since y was constant) a = floor(x) + floor(z).  If a was even, we colored it white, if a was odd, we did black (like reference solution).

Floor: to do the floor, we created 4 triangles.  All triangles had a point at (0, -2, 0).  The other 4 points used to create 4
triangles were (+- inf, -2, +- inf).
