Team: Amit Joshi and Dora Gurfinkel
Note: We received an extension until March 15 12am (due to sickness, as well as setup issues for remote work due to COVID)

Required Features:

Relocate:
Just some modifications to our initialization code for camera and light.

Toggling:
Done by switching some booleans in the callbacks.

Green wireframes:
We used the Polygon Mode as suggested, interpolated per vertex barycentric coordinates (set in the geometry shader) and checked to see if within a threshold in the fragment shader.
If within the threshold, we colored it green. This is rendered through a tessellation pipeline using the geometry generated by the replaced floor.

Replacing the floor:
We came up with an algorithm to generate the vertices/faces for a quad floor of given dimension and checked it in Meshlab.
We then rendered it by sending it through the tesselation shaders.

TCS:
Just sets inner/outer tessellation levels based off of a passed in uniform whose value is controlled by keyboard pressed.
Default inner = 2, outer = 3 (randomly chosen).

TES:
Interpolates global coordinates, light_position, and later also modifies the new vertices positions (if the ocean is rendering).

Ocean Mode:

Displacement/Normal Mapping: We did displacement mapping by having 3 sets of wave parameters (since 3 non-tidal waves total) in our TES for the ocean.  We used the sine wave approximation. We calculated the total non-tidal displacement at a particular time (this time was passed in through a uniform variable) by summing the displacements of each wave.  We also calculated the tidal wave displacement by having a separate equation for the tidal wave.  We passed in two uniforms, one represented whether the tidal wave was “on” and the other represented the x-coordinate of the tidal wave.  We then modified the y coordinate of gl_Position by this height increase, given by the sum of the non-tidal wave displacement and tidal wave displacement.  For calculation of the normals, we followed the equations from the GPU gems article (but accounted for the fact that y was our up direction) to add the normal components for each non-tidal wave.  For the tidal wave, we calculated the normal ourselves.  We summed these together and then normalized the result to give the normalized normal for a particular point.
Tidal Wave: For the tidal wave, we had 2 variables in main.cc, one which represented the existence of the tidal wave and one which represented the x-coordinate of the tidal wave.  When a tidal wave was triggered by the user, the x-coordinate would be set to 0, and the boolean would be set to true.  Once the tidal wave went off-screen, the tidal wave boolean would be set to false.  Details of tidal displacement/normal above.

Adaptive Tessellation: We determine how far the four coordinates of the quad are from the mean of the gaussian curve and then scalar multiply the inner/outer tessellation levels as appropriate (clamped [1, 4]).  Specifically, we calculated the mean distance from each of the quad’s vertices.  We then tuned this by dividing this mean by 16. Four minus this result was the scalar multiplier for inner and outer tessellation.  Basically as described in the instructions.

Illumination of water: We tried some random numbers until it worked, using the normal phong shading equations we had used in ray tracer.  We did ambient, diffuse, and specular components.  We assumed the ambient light shining would be  fully blue-green and only introduced a partial red component on the specular term. For the diffuse term, we assumed the object was pure blue-green as well. This meant passing in more information as uniforms, i.e. camera position.

EXTRA CREDIT: (+25)
------------
Even wireframe thickness: (+5)
In order to ensure that as tessellation increases the thickness is as equal as possible, I specify  equal spacing in the layout so as to avoid unequally sized triangles.
The threshold is also small enough such that differences in thickness are not detectable by the human eye.

-------------
current position of light: isosphere (+5)
I looked up an isosphere mesh and then translated it to be at the location of the light. I shade it as pure white, thinking that was the best approximation to emissive light. This is rendered without tesselation and with its own program. Fairly simple.

--------------
Shadow  (+5)
We determine what area on the current ocean surface is blocked by the menger sponge and then multiply it’s color by a constant shadow attenuator (0.7) to decrease the intensity.
---------------
Boat mesh (+10) - we found a boat mesh online and then created a parser to reading in the .obj file and convert it into a vector of vertices and vectors (hence why our program takes a second to start up, it’s reading this all in). As we read in, we do the reflections necessary to have the boat right side up. The boat’s vertex shader translates the entire boat up by the height of the wave at the center of the boat. The boat is colored in red in its fragment shader and does normal diffuse lighting.
